/*-------------------------------------------------------------------------------------
   servo.c  LIBRARY FOR CONTROLLING UP OT ALL PINGUINO PINS AS SERVOS FOR 18F2550/4550/PICUNO
   ====================================================================================

             Version: 2.1
			 copyright  JesÃºs Carmona Esteban
			 Date: 5/4/2012

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
--------------------------------------------------------------------------------------*/

// This library is optimized for Pinguino 18F2550/4550/PICUNO_EQUO
// it allows to drive up to 14 servos simultaneously with PICUNO EQUO, 
//  18 servos simultaneously with 2550, and 29 with 4550.
// So, that all Pinguino pins on 18F2550/4550 can be configured as servo drivers.
//
// NOTES: 
// - Xtal must be 20 Mhz. Thus the resulting clock after PLL will be
//   of 48Mhz => 12 MIPS (Fosc/4).
// - This library allows 250 positions for a servo, corresponding 
//   1 to 500 usecs, and 250 to 2500 usec aprox. Those 1-250 values are mapped from 0-180 degrees
//   which is the value that user will put in servo.write function.
// - Input by user would be in degrees. 
// - There is now a correspondence table where is stored maximum and minimum 
//   values that a servo could reach in miliseconds. But the value stored is from 1 to 250.
// - All servos are automatically refreshed by PIC in a parallel way.
// 
// 
//	New timeslots for version 2: 
//
// TIMESLOT(byte value):
// 1                  62                  125                  187                  250
// |-------------------|-------------------|--------------------|--------------------|
// 500               1000                 1500                2000                 2500
// Time (microseconds)
//
// Defaul values now for SERVOMAX and SERVOMIN should be 64 and 192, 1000usec and 2000usec respectively.
// This means steps of 8 microseconds for every timeslot.
//
// -------------------------------------------------------------------------------------------------------


#define SERVOSLIBRARY 1


// Max and Min values that correspond to 2000 usec and 1000 usec:
#define DefaultSERVOMAX 192
#define DefaultSERVOMIN  64


//library internal variables:
uchar phase=0;
uchar needreordering=0;
//-----------------------------------------------------------------------------------------------------------------------------
#if defined(PICUNO_EQUO)
#define PICUNO_EQUO_pins 14  // It only uses digital pins: D00-D13.
uchar timingindex;
uchar timedivision=0;
uchar loopvar;
uchar timings[4][PICUNO_EQUO_pins];  
uchar activatedservos[3]={0x00,0x00,0x00};
// For referencing masks in the previous array.
#define MaskPort_B  0
#define MaskPort_C  1
#define MaskPort_D  2
#define timevalue   3

uchar servovalues[PICUNO_EQUO_pins]; // Entry table for values sets for every pin-servo.

uchar maxminpos[2][PICUNO_EQUO_pins]; // This table keeps maximum(180 degrees) and minimum(0 degrees) values that the servo can reach

//Masks table:
const uchar servomasks[PICUNO_EQUO_pins]={
 0x80, 0x40,0x04,0x08,0x01,0x04,0x02,0x02,0x04,0x08,0x10,0x20,0x40,0x80};
//RC7, RC6, RB2, RB3, RD0, RC2, RC1, RD1 ,RD2 ,RD3 ,RD4 ,RD5 ,RD6 ,RD7
// 0 ,  1 ,  2 ,  3 ,  4 ,  5 ,  6 ,  7  , 8  , 9  , 10 , 11,  12 , 13
 
void servos_init()
{
	unsigned char a;

	for(a=0;a<PICUNO_EQUO_pins;a++) servovalues[a]=255;


	TMR1H=0xFF;
	TMR1L=0x00;
	// timer 1 prescaler 1 source is internal oscillator
	T1CON=0x01;
	// enable interrupt for timer1 in register PIE1
	PIE1bits.TMR1IE=1;
	// enable peripheral interrupt
	INTCONbits.PEIE=1;
	// global enable interrupt
	INTCONbits.GIE=1;
	// now the first interrupt will be generated by timer2 after 9 ms.
}


static void ServosPulseDown()
{
	timingindex = 0;
	
	for(timedivision=0;timedivision < 251;timedivision++){
		if (timings[timevalue][timingindex] == timedivision){
			PORTB = PORTB ^ timings[MaskPort_B][timingindex];
			PORTC = PORTC ^ timings[MaskPort_C][timingindex];
			PORTD = PORTD ^ timings[MaskPort_D][timingindex];
			timingindex++;
		}
		// OLD: the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 4 usec.
		// NEW: the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 8 usec.
		__asm 
			movlw 6
			movwf _loopvar
		bucle:
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			decfsz _loopvar,1
			goto bucle
		__endasm;
	}
}

static void ServosPulseUp()
{
// This function starts up pulses for all activated servos.
	PORTB = activatedservos[MaskPort_B] & 0xFF;
	PORTC = activatedservos[MaskPort_C] & 0xFF;
	PORTD = activatedservos[MaskPort_D] & 0xFF;		
}


static void SortServoTimings()
{
// This funtion analyses servovalues table and creates and ordered table(timings)
// from smaller to bigger of all the values, asociating to each 
// position of the table the servos that matches that timing.

	uchar s,t,totalservos,numservos;
	uchar mascaratotal[3]={0x00,0x00,0x00};
	
	// inicializamos la tabla:
	for(t=0;t<PICUNO_EQUO_pins;t++){
		timings[timevalue][t]=255;
		timings[MaskPort_B][t]=0x00;
		timings[MaskPort_C][t]=0x00;
		timings[MaskPort_D][t]=0x00;
	}
	
	totalservos=0;
	t=0;
	while(totalservos<PICUNO_EQUO_pins) {
		numservos=1;
		for(s=0;s<PICUNO_EQUO_pins;s++) { 
			// Case that we are reviewing PORTB servos:
			if (s==2 || s==3){
				if (servomasks[s] & mascaratotal[MaskPort_B] & activatedservos[MaskPort_B]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=servomasks[s];
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_D][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_B][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTD servos:
			else if (s==4 || s>=7){
				if (servomasks[s] & mascaratotal[MaskPort_D] & activatedservos[MaskPort_D]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_D][t]=servomasks[s];
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_D][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTC servos:
			else {
				if (servomasks[s] & mascaratotal[MaskPort_C] & activatedservos[MaskPort_C]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=servomasks[s];
					timings[MaskPort_D][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_C][t] |= servomasks[s];
					numservos++;
				}
			}				
			
		}
		mascaratotal[MaskPort_B] |= timings[MaskPort_B][t];
		mascaratotal[MaskPort_C] |= timings[MaskPort_C][t];
		mascaratotal[MaskPort_D] |= timings[MaskPort_D][t];
		totalservos += numservos;
		t++;
	
	}
	needreordering=0;  // This indicates that servo timings is ordered.	
}	


	
void ServoAttach(uchar pin)
{
	if(pin>=PICUNO_EQUO_pins) return;

	if(pin==2 || pin==3){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] | servomasks[pin];  // list pin as servo driver.
		TRISB = TRISB & (255 - servomasks[pin]); // set as output pin
	} else if (pin==4 || pin>=7){
		activatedservos[MaskPort_D] = activatedservos[MaskPort_D] | servomasks[pin];  // list pin as servo driver.
		TRISD = TRISD & (255 - servomasks[pin]); // set as output pin
	} else {
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] | servomasks[pin];  // list pin as servo driver.
		TRISC = TRISC & (255 - servomasks[pin]); // set as output pin
	}
	
}

void ServoDetach(uchar pin)
{
	if(pin>=PICUNO_EQUO_pins) return;

	if(pin==2 || pin==3){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] ^ servomasks[pin];
	} else if (pin==4 || pin>=7){
		activatedservos[MaskPort_D] = activatedservos[MaskPort_D] ^ servomasks[pin];
	} else {
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] ^ servomasks[pin];
	}
	
}

void ServoWrite(unsigned char servo,unsigned char degrees)
{
	unsigned char difference;
	float ticksperdegree;
	unsigned char value;

    // test if numservo is valid
	if(servo>=PICUNO_EQUO_pins) {
		return;
	}
    // limitting degrees:
	if(degrees>180) {
		degrees=180;
	}

	// This is the formula to convert from degrees to timeslots for that specific servo:
	difference = (maxminpos[1][servo]-maxminpos[0][servo]);
	ticksperdegree = ((float)difference/180);
	value = abs(degrees*ticksperdegree) + maxminpos[0][servo];
    

	// Storage of that new position to servovalues positions table:
	// it should be added the min value for that servo
	servovalues[servo]= value;
	
	needreordering=1;  // This indicates servo timings must be reordered.
}



unsigned char ServoRead(uchar servo)
{
	if(servo>=PICUNO_EQUO_pins)        // test if numservo is valid
		return 0;
	return servovalues[servo];
}


void ServoMinimumPulse(unsigned char servo,int min_microseconds)
{
	unsigned char final_min;

    // test if numservo is valid:
	if(servo>=PICUNO_EQUO_pins)        
		return;
    // test if microseconds are within range:
	if((min_microseconds<500) || (min_microseconds>2500))
		return;

	// The following formula converts from microseconds to timeslot:
	final_min=(min_microseconds-500+1)/8;

    // Store in 1st column the minimum value allowed from now on to that servo:
    maxminpos[0][servo]=final_min; 
}

void ServoMaximumPulse(unsigned char servo,int max_microseconds)
{
	unsigned char final_max;

    // test if numservo is valid:
	if(servo>=PICUNO_EQUO_pins)        
		return;
    // test if microseconds are within range:
	if((max_microseconds<500) || (max_microseconds>2500))
		return;

	// The following formula converts from microseconds to timeslot:
	final_max=(max_microseconds-500+1)/8;

    // Store in 1st column the minimum value allowed from now on to that servo:
    maxminpos[1][servo]=final_max; 
}

//interrupt handler that handles servos
void servos_interrupt(void)
{
	if (PIR1bits.TMR1IF) {
		PIR1bits.TMR1IF=0;
		T1CON=0x00;
		if (phase) {
		//case before 500 microseconds:
			ServosPulseUp();
			//OLD: Load at TMR1 54159d(also 0xFFFF - 12000d (- 54usec for adjustments))= 0xd38f.
			//NEW: Load at TMR1 (65535d - 6000d (-54usec for adjusments ) = 59481d = 0xE859
			TMR1H= 0xe8;
			TMR1L= 0x59;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (CPU clock or Fosc=48Mhz).
			T1CON=1;
			phase = 0;
		} 
		else {
		//case before 2500 microseconds:
			//The following call takes 2 ms aprox.:
			ServosPulseDown();
			// OLD: Now it takes place a 18 ms delay, after that a interrupt will be generated.
			// OLD:Loading at TMR1 11535d (que es: 0xFFFF - (4,5 x 12000(duracion 1ms)) = 0x2D0F => a 4,5 ms) 
			// OLD: This 4,5 x 4 (with preescaler x 4) we get 18 ms delay.
			// NEW: after 2,5 ms we need a delay of 17,5 ms to complete a 20 ms cycle.
			// NEW: Loading at TMR1 65535d - (4,375 x 12000(=1ms)=) 52500d = 13035d = 0x32EB => 4,375 ms
			// NEW: This is 4,375ms x 4 (preescaler) = 17,5 ms
			TMR1H= 0x32;
			TMR1L= 0xeb;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (recordemos que Fosc=48Mhz).
			if (needreordering)	
				SortServoTimings();  // This takes more than 1 ms, but it's call only if needed.
			T1CON= ( 1 | 2 << 4 ) ; // activate timer1 and prescaler = 1:4
			phase = 1;  //This indicates that after next interrupt it will start the servos cycle.
		} 
	}
	return;
}
//----------------------------------------------------------------------------------------------------------------------------------
#elif defined(PIC18F4550)
#define PIC18F4550_pins 29
uchar timingindex;
uchar timedivision=0;
uchar loopvar;
uchar timings[6][PIC18F4550_pins];  
uchar activatedservos[5]={0x00,0x00,0x00,0x00,0x00};
// For masks referencing in the previous array.
#define MaskPort_B  0
#define MaskPort_C  1
#define MaskPort_A  2
#define MaskPort_E  3
#define MaskPort_D  4
#define timevalue   5

uchar servovalues[PIC18F4550_pins]; // Entry table for values sets for every pin-servo.

uchar maxminpos[2][PIC18F4550_pins]; // This table keeps maximum(180 degrees) and minimum(0 degrees) values that the servo can reach

//Masks table:
const uchar servomasks[PIC18F4550_pins]=
{0X01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,    // Register B (RB0,RB1,RB2,RB3,RB4,RB5,RB6,RB7)
0x40,0x80,0x01,0x02,0x04,    				 // Register C (RC6,RC7,RC0,RC1,RC2)
0x01,0x02,0x04,0x08,0x20,					 // Register A (RA0,RA1,RA2,RA3,RA5)
0x01,0x02,0x04,								 // Register E (RE0,RE1,RE2)
0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80};    // REgister D (RD0,RD1,RD2,RD3,RD4,RD5,RD6,RD7)

void servos_init()
{
	unsigned char a;

	for(a=0;a<PIC18F4550_pins;a++) servovalues[a]=255;


	TMR1H=0xFF;
	TMR1L=0x00;
	// timer 1 prescaler 1 source is internal oscillator
	T1CON=0x01;
	// enable interrupt for timer1 in register PIE1
	PIE1bits.TMR1IE=1;
	// enable peripheral interrupt
	INTCONbits.PEIE=1;
	// global enable interrupt
	INTCONbits.GIE=1;
	// now the first interrupt will be generated by timer2 after 9 ms.
}


static void ServosPulseDown()
{
	timingindex = 0;
	
	for(timedivision=0;timedivision < 251;timedivision++){
		if (timings[timevalue][timingindex] == timedivision){
			PORTB = PORTB ^ timings[MaskPort_B][timingindex];
			PORTC = PORTC ^ timings[MaskPort_C][timingindex];
			PORTA = PORTA ^ timings[MaskPort_A][timingindex];
			PORTE = PORTE ^ timings[MaskPort_E][timingindex];
			PORTD = PORTD ^ timings[MaskPort_D][timingindex];
			timingindex++;
		}
		// OLD: the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 4 usec.
		// NEW: the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 8 usec.
		__asm 
			movlw 6
			movwf _loopvar
		bucle:
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			decfsz _loopvar,1
			goto bucle
		__endasm;
	}
}

static void ServosPulseUp()
{
// This function starts up pulses for all activated servos.
	PORTB = activatedservos[MaskPort_B] & 0xFF;
	PORTC = activatedservos[MaskPort_C] & 0xFF;
	PORTA = activatedservos[MaskPort_A] & 0xFF;
	PORTE = activatedservos[MaskPort_E] & 0xFF;
	PORTD = activatedservos[MaskPort_D] & 0xFF;		
}


static void SortServoTimings()
{
// This funtion analyses servovalues table and creates and ordered table(timings)
// from smaller to bigger of all the values, asociating to each 
// position of the table the servos that matches that timing.

	uchar s,t,totalservos,numservos;
	uchar mascaratotal[5]={0x00,0x00,0x00,0x00,0x00};
	
	// inicializamos la tabla:
	for(t=0;t<PIC18F4550_pins;t++){
		timings[timevalue][t]=255;
		timings[MaskPort_B][t]=0x00;
		timings[MaskPort_C][t]=0x00;
		timings[MaskPort_A][t]=0x00;
		timings[MaskPort_E][t]=0x00;
		timings[MaskPort_D][t]=0x00;
	}
	
	totalservos=0;
	t=0;
	while(totalservos<PIC18F4550_pins) {
		numservos=1;
		for(s=0;s<PIC18F4550_pins;s++) { 
			// Case that we are reviewing PORTB servos:
			if (s<8){
				if (servomasks[s] & mascaratotal[MaskPort_B] & activatedservos[MaskPort_B]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=servomasks[s];
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					timings[MaskPort_E][t]=0x00;
					timings[MaskPort_D][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_B][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTC servos:
			else if (s<13){
				if (servomasks[s] & mascaratotal[MaskPort_C] & activatedservos[MaskPort_C]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=servomasks[s];
					timings[MaskPort_A][t]=0x00;
					timings[MaskPort_E][t]=0x00;
					timings[MaskPort_D][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_C][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTA servos:
			else if (s<18){
				if (servomasks[s] & mascaratotal[MaskPort_A] & activatedservos[MaskPort_A]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=servomasks[s];
					timings[MaskPort_E][t]=0x00;
					timings[MaskPort_D][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_A][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTE servos:
			else if (s<21){
				if (servomasks[s] & mascaratotal[MaskPort_E] & activatedservos[MaskPort_E]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					timings[MaskPort_E][t]=servomasks[s];
					timings[MaskPort_D][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_E][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTD servos:
			else {
				if (servomasks[s] & mascaratotal[MaskPort_D] & activatedservos[MaskPort_D]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					timings[MaskPort_E][t]=0x00;
					timings[MaskPort_D][t]=servomasks[s];
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_D][t] |= servomasks[s];
					numservos++;
				}
			}				
			
		}
		mascaratotal[MaskPort_B] |= timings[MaskPort_B][t];
		mascaratotal[MaskPort_C] |= timings[MaskPort_C][t];
		mascaratotal[MaskPort_A] |= timings[MaskPort_A][t];
		mascaratotal[MaskPort_E] |= timings[MaskPort_E][t];
		mascaratotal[MaskPort_D] |= timings[MaskPort_D][t];
		totalservos += numservos;
		t++;
	
	}
	needreordering=0;  // This indicates that servo timings is ordered.	
}	


	
void ServoAttach(uchar pin)
{
	if(pin>=PIC18F4550_pins) return;

	if(pin<8){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] | servomasks[pin];  // list pin as servo driver.
		TRISB = TRISB & (255 - servomasks[pin]); // set as output pin
	} else if (pin<13){
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] | servomasks[pin];  // list pin as servo driver.
		TRISC = TRISC & (255 - servomasks[pin]); // set as output pin
	} else if (pin<18) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] | servomasks[pin];  // list pin as servo driver.
		TRISA = TRISA & (255 - servomasks[pin]); // set as output pin
	} else if (pin<21){
		activatedservos[MaskPort_E] = activatedservos[MaskPort_E] | servomasks[pin];  // list pin as servo driver.
		TRISE = TRISE & (255 - servomasks[pin]); // set as output pin
	} else {
		activatedservos[MaskPort_D] = activatedservos[MaskPort_D] | servomasks[pin];  // list pin as servo driver.
		TRISD = TRISD & (255 - servomasks[pin]); // set as output pin
	}
	
}

void ServoDetach(uchar pin)
{
	if(pin>=PIC18F4550_pins) return;

	if(pin<8){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] ^ servomasks[pin];
	} else if (pin<13){
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] ^ servomasks[pin];
	} else if (pin<18) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] ^ servomasks[pin];
	} else if (pin<21){
		activatedservos[MaskPort_E] = activatedservos[MaskPort_E] ^ servomasks[pin];
	} else {
		activatedservos[MaskPort_D] = activatedservos[MaskPort_D] ^ servomasks[pin];
	}
	
}

void ServoWrite(unsigned char servo,unsigned char degrees)
{
	unsigned char difference;
	float ticksperdegree;
	unsigned char value;

    // test if numservo is valid
	if(servo>=PIC18F4550_pins) {
		return;
	}
    // limitting degrees:
	if(degrees>180) {
		degrees=180;
	}

	// This is the formula to convert from degrees to timeslots for that specific servo:
	difference = (maxminpos[1][servo]-maxminpos[0][servo]);
	ticksperdegree = ((float)difference/180);
	value = abs(degrees*ticksperdegree) + maxminpos[0][servo];
    

	// Storage of that new position to servovalues positions table:
	// it should be added the min value for that servo
	servovalues[servo]= value;
	
	needreordering=1;  // This indicates servo timings must be reordered.
}


unsigned char ServoRead(uchar servo)
{
	if(servo>=PIC18F4550_pins)        // test if numservo is valid
		return 0;
	return servovalues[servo];
}

void ServoMinimumPulse(unsigned char servo,int min_microseconds)
{
	unsigned char final_min;

    // test if numservo is valid:
	if(servo>=PIC18F4550_pins)        
		return;
    // test if microseconds are within range:
	if((min_microseconds<500) || (min_microseconds>2500))
		return;

	// The following formula converts from microseconds to timeslot:
	final_min=(min_microseconds-500+1)/8;

    // Store in 1st column the minimum value allowed from now on to that servo:
    maxminpos[0][servo]=final_min; 
}

void ServoMaximumPulse(unsigned char servo,int max_microseconds)
{
	unsigned char final_max;

    // test if numservo is valid:
	if(servo>=PIC18F4550_pins)        
		return;
    // test if microseconds are within range:
	if((max_microseconds<500) || (max_microseconds>2500))
		return;

	// The following formula converts from microseconds to timeslot:
	final_max=(max_microseconds-500+1)/8;

    // Store in 1st column the minimum value allowed from now on to that servo:
    maxminpos[1][servo]=final_max; 
}




//interrupt handler that handles servos
void servos_interrupt(void)
{
	if (PIR1bits.TMR1IF) {
		PIR1bits.TMR1IF=0;
		T1CON=0x00;
		if (phase) {
		//case before 500 microseconds:
			ServosPulseUp();
			//OLD: Load at TMR1 54159d(also 0xFFFF - 12000d (- 54usec for adjustments))= 0xd38f.
			//NEW: Load at TMR1 (65535d - 6000d (-54usec for adjusments ) = 59481d = 0xE859
			TMR1H= 0xe8;
			TMR1L= 0x59;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (CPU clock or Fosc=48Mhz).
			T1CON=1;
			phase = 0;
		} 
		else {
		//case before 2500 microseconds:
			//The following call takes 2 ms aprox.:
			ServosPulseDown();
			// OLD: Now it takes place a 18 ms delay, after that a interrupt will be generated.
			// OLD:Loading at TMR1 11535d (que es: 0xFFFF - (4,5 x 12000(duracion 1ms)) = 0x2D0F => a 4,5 ms) 
			// OLD: This 4,5 x 4 (with preescaler x 4) we get 18 ms delay.
			// NEW: after 2,5 ms we need a delay of 17,5 ms to complete a 20 ms cycle.
			// NEW: Loading at TMR1 65535d - (4,375 x 12000(=1ms)=) 52500d = 13035d = 0x32EB => 4,375 ms
			// NEW: This is 4,375ms x 4 (preescaler) = 17,5 ms
			TMR1H= 0x32;
			TMR1L= 0xeb;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (recordemos que Fosc=48Mhz).
			if (needreordering)	
				SortServoTimings();  // This takes more than 1 ms, but it's call only if needed.
			T1CON= ( 1 | 2 << 4 ) ; // activate timer1 and prescaler = 1:4
			phase = 1;  //This indicates that after next interrupt it will start the servos cycle.
		} 
	}
	return;
}
//----------------------------------------------------------------------------------------------------------------------------------
#else
#define PIC18F2550_pins 18
uchar timingindex;
uchar timedivision=0;
uchar loopvar;
uchar timings[4][PIC18F2550_pins];
 
uchar activatedservos[3]={0x00,0x00,0x00};
// For masks referencing in the previous array.
#define MaskPort_B  0
#define MaskPort_C  1
#define MaskPort_A  2
#define timevalue   3

uchar servovalues[PIC18F2550_pins]; // Entry table for values sets for every pin-servo.

uchar maxminpos[2][PIC18F2550_pins]; // This table keeps maximum(180 degrees) and minimum(0 degrees) values that the servo can reach

//Masks table:
const uchar servomasks[PIC18F2550_pins]=
{0X01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,	// Register B (RB0,RB1,RB2,RB3,RB4,RB5,RB6,RB7)
0x40,0x80,0x01,0x02,0x04,					// Register C (RC6,RC7,RC0,RC1,RC2)
0x01,0x02,0x04,0x08,0x20};					// Register A (RA0,RA1,RA2,RA3,RA5)


 
void servos_init()
{
	unsigned char a;

	for(a=0;a<PIC18F2550_pins;a++) {
		servovalues[a]=255;
	}


	TMR1H=0xFF;
	TMR1L=0x00;
	// timer 1 prescaler 1 source is internal oscillator
	T1CON=0x01;
	// enable interrupt for timer1 in register PIE1
	PIE1bits.TMR1IE=1;
	// enable peripheral interrupt
	INTCONbits.PEIE=1;
	// global enable interrupt
	INTCONbits.GIE=1;
	// now the first interrupt will be generated by timer2 after 9 ms.
}


static void ServosPulseDown()
{
	timingindex = 0;
	
	for(timedivision=0;timedivision < 251;timedivision++){
		if (timings[timevalue][timingindex] == timedivision){
			PORTB = PORTB ^ timings[MaskPort_B][timingindex];
			PORTC = PORTC ^ timings[MaskPort_C][timingindex];
			PORTA = PORTA ^ timings[MaskPort_A][timingindex];
			timingindex++;
		}
		// OLD: the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 4 usec.
		// NEW: the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 8 usec.
		__asm 
			movlw 6
			movwf _loopvar
		bucle:
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			NOP
			decfsz _loopvar,1
			goto bucle
		__endasm;
	}
}

static void ServosPulseUp()
{
// This function starts up pulses for all activated servos.
	PORTB = activatedservos[MaskPort_B] & 0xFF;
	PORTC = activatedservos[MaskPort_C] & 0xFF;
	PORTA = activatedservos[MaskPort_A] & 0xFF;	
}


static void SortServoTimings()
{
// This funtion analyses servovalues table and creates and ordered table(timings)
// from smaller to bigger of all the values, asociating to each 
// position of the table the servos that matches that timing.

	uchar s,t,totalservos,numservos;
	uchar mascaratotal[3]={0x00,0x00,0x00};
	
	// initializing table:
	for(t=0;t<PIC18F2550_pins;t++){
		timings[timevalue][t]=255;
		timings[MaskPort_B][t]=0x00;
		timings[MaskPort_C][t]=0x00;
		timings[MaskPort_A][t]=0x00;
	}
	
	totalservos=0;
	t=0;
	while(totalservos<PIC18F2550_pins) {
		numservos=1;
		for(s=0;s<PIC18F2550_pins;s++) { 
			// Case that we are reviewing PORTB servos:
			if (s<8){
				if (servomasks[s] & mascaratotal[MaskPort_B] & activatedservos[MaskPort_B]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=servomasks[s];
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_B][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTA servos:
			else if (s>12){
				if (servomasks[s] & mascaratotal[MaskPort_A] & activatedservos[MaskPort_A]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=servomasks[s];
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_A][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTC servos:
			else {
				if (servomasks[s] & mascaratotal[MaskPort_C] & activatedservos[MaskPort_C]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=servomasks[s];
					timings[MaskPort_A][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_C][t] |= servomasks[s];
					numservos++;
				}
			}				
			
		}
		mascaratotal[MaskPort_B] |= timings[MaskPort_B][t];
		mascaratotal[MaskPort_C] |= timings[MaskPort_C][t];
		mascaratotal[MaskPort_A] |= timings[MaskPort_A][t];
		totalservos += numservos;
		t++;
	
	}
	needreordering=0;  // This indicates that servo timings is ordered.	
}	


	
void ServoAttach(uchar pin)
{
	if(pin>=PIC18F2550_pins) return;

	if(pin<8){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] | servomasks[pin];  // list pin as servo driver.
		TRISB = TRISB & (255 - servomasks[pin]); // set as output pin
	} else if (pin>12) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] | servomasks[pin];  // list pin as servo driver.
		TRISA = TRISA & (255 - servomasks[pin]); // set as output pin
	} else {
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] | servomasks[pin];  // list pin as servo driver.
		TRISC = TRISC & (255 - servomasks[pin]); // set as output pin
	}
//    maxminpos[0][pin]=DefaultSERVOMIN; // First table column is for minimum values.
//	maxminpos[1][pin]=DefaultSERVOMAX; // Seconds table column is for maximum values.

	
}

void ServoDetach(uchar pin)
{
	if(pin>=PIC18F2550_pins) return;

	if(pin<8){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] ^ servomasks[pin];
	} else if (pin>12) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] ^ servomasks[pin];
	} else {
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] ^ servomasks[pin];
	}
	
}


void ServoWrite(unsigned char servo,unsigned char degrees)
{
	unsigned char difference;
	float ticksperdegree;
	unsigned char value;

    // test if numservo is valid
	if(servo>=PIC18F2550_pins) {
		return;
	}
    // limitting degrees:
	if(degrees>180) {
		degrees=180;
	}

	// This is the formula to convert from degrees to timeslots for that specific servo:
	difference = (maxminpos[1][servo]-maxminpos[0][servo]);
	ticksperdegree = ((float)difference/180);
	value = abs(degrees*ticksperdegree) + maxminpos[0][servo];
    

	// Storage of that new position to servovalues positions table:
	// it should be added the min value for that servo
	servovalues[servo]= value;
	
	needreordering=1;  // This indicates servo timings must be reordered.
}


unsigned char ServoRead(uchar servo)
{
	if(servo>=PIC18F2550_pins)        // test if numservo is valid
		return 0;
	return servovalues[servo];
}


void ServoMinimumPulse(unsigned char servo,int min_microseconds)
{
	unsigned char final_min;

    // test if numservo is valid:
	if(servo>=PIC18F2550_pins)        
		return;
    // test if microseconds are within range:
	if((min_microseconds<500) || (min_microseconds>2500))
		return;

	// The following formula converts from microseconds to timeslot:
	final_min=(min_microseconds-500+1)/8;

    // Store in 1st column the minimum value allowed from now on to that servo:
    maxminpos[0][servo]=final_min; 
}


void ServoMaximumPulse(unsigned char servo,int max_microseconds)
{
	unsigned char final_max;

    // test if numservo is valid:
	if(servo>=PIC18F2550_pins)        
		return;
    // test if microseconds are within range:
	if((max_microseconds<500) || (max_microseconds>2500))
		return;

	// The following formula converts from microseconds to timeslot:
	final_max=(max_microseconds-500+1)/8;

    // Store in 1st column the minimum value allowed from now on to that servo:
    maxminpos[1][servo]=final_max; 
}



//interrupt handler that handles servos
void servos_interrupt(void)
{
	if (PIR1bits.TMR1IF) {
		PIR1bits.TMR1IF=0;
		T1CON=0x00;
		if (phase) {
		//case before 500 microseconds:
			ServosPulseUp();
			//OLD: Load at TMR1 54159d(also 0xFFFF - 12000d (- 54usec for adjustments))= 0xd38f.
			//NEW: Load at TMR1 (65535d - 6000d (-54usec for adjusments ) = 59481d = 0xE859
			TMR1H= 0xe8;
			TMR1L= 0x59;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (CPU clock or Fosc=48Mhz).
			T1CON=1;
			phase = 0;
		} 
		else {
		//case before 2500 microseconds:
			//The following call takes 2 ms aprox.:
			ServosPulseDown();
			// OLD: Now it takes place a 18 ms delay, after that a interrupt will be generated.
			// OLD:Loading at TMR1 11535d (que es: 0xFFFF - (4,5 x 12000(duracion 1ms)) = 0x2D0F => a 4,5 ms) 
			// OLD: This 4,5 x 4 (with preescaler x 4) we get 18 ms delay.
			// NEW: after 2,5 ms we need a delay of 17,5 ms to complete a 20 ms cycle.
			// NEW: Loading at TMR1 65535d - (4,375 x 12000(=1ms)=) 52500d = 13035d = 0x32EB => 4,375 ms
			// NEW: This is 4,375ms x 4 (preescaler) = 17,5 ms
			TMR1H= 0x32;
			TMR1L= 0xeb;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (recordemos que Fosc=48Mhz).
			if (needreordering)	
				SortServoTimings();  // This takes more than 1 ms, but it's call only if needed.
			T1CON= ( 1 | 2 << 4 ) ; // activate timer1 and prescaler = 1:4
			phase = 1;  //This indicates that after next interrupt it will start the servos cycle.
		} 
	}
	return;
}
#endif
