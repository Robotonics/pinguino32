/*-------------------------------------------------------------------------
	servo.c  LIBRARY FOR CONTROLLING UP TO 18 SERVO WITH PINGUINO 18F2550
    =====================================================================

             Version: 1.0
			 copyright  JesÃºs Carmona Esteban
			 Date: 28/7/2010

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-------------------------------------------------------------------------*/

// This library is optimized for Pinguino 18F2550 
// it allows to drive up to 18 servos simultaneously. So, all 
// Pinguino 18F2550 pins can be configured as servo drivers.
//
// NOTES: 
// - Xtal must be 20 Mhz. Thus the resulting clock after PLL will be
//   of 48Mhz => 12 MIPS (Fosc/4).
// - This library allows 250 positions for a servo, corresponding 
//   1 to 1000 usecs, and 250 to 2000 usec aprox.
// - All servos are automatically refreshed by PIC in a parallel way.
// 
// 
// -----------------------------------------------------------------------------

#define SERVOSLIBRARY 1

#include <typedef.h>			// u8, u16, ...

// Max and Min values allowed:
#define SERVOMAX 250
#define SERVOMIN   1


//library internal variables:
u8 phase=0;
u8 needreordering=0;
//-----------------------------------------------------------------------------------------------------------------------------
#ifdef PICUNO_EQUO
u8 timingindex;
u8 timedivision=0;
u8 loopvar;
u8 timings[6][30];  
u8 activatedservos[5]={0x00,0x00,0x00,0x00,0x00};
// For referencing masks in the previous array.
#define MaskPort_B  0
#define MaskPort_C  1
#define MaskPort_A  2
#define MaskPort_E  3
#define MaskPort_D  4
#define timevalue   5

u8 servovalues[30]; // Entry table for values sets for every pin-servo.

//Masks table:
//u8 servomasks[8]={ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
// The following masks are in this order : PORTB (8 bits), PORTC (5bits) & PORTA (5bits)
const u8 servomasks[30]={0X80,0x40,0x10,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x01,0x02,0x04,0x01,0x02,0x04,0x08,0x20,0x01,0x02,0x04,0x01,0x02,0x04,0x08,0x80,0x40,0x20,0x10};
						// 	RC7	,RC6 ,RA4 ,RB0 ,RB1 ,RB2 ,RB3 ,RB4 ,RB5 ,RB6 ,RB7 ,RC0 ,RC1 ,RC2 ,RA0 ,RA1 ,RA2 ,RA3 ,RA5 ,RE0 ,RE1 ,RE2 ,RD0 ,RD1 ,RD2 ,RD3 ,RD7 ,RD6 ,RD5 ,RD4
 
void servos_init()
{
	unsigned char a;

	for(a=0;a<30;a++) servovalues[a]=255;


	TMR1H=0xFF;
	TMR1L=0x00;
	// timer 1 prescaler 1 source is internal oscillator
	T1CON=0x01;

    PIR1bits.TMR1IF=0;              // Clear interrupt flag
    PIE1bits.TMR1IE=1;              // Enable interrupt for timer1 in register PIE1
    IPR1bits.TMR1IP=1;              // High priority
    //RCONbits.IPEN = 1;              // Enable interrupt priorities
    INTCONbits.GIEH = 1;            // Enable global HP interrupts
    INTCONbits.GIEL = 1;            // Enable global LP interrupts

	// now the first interrupt will be generated by timer2 after 9 ms.
}


static void ServosPulseDown()
{
	timingindex = 0;
	
	for(timedivision=0;timedivision < 251;timedivision++){
		if (timings[timevalue][timingindex] == timedivision){
			PORTB = PORTB ^ timings[MaskPort_B][timingindex];
			PORTC = PORTC ^ timings[MaskPort_C][timingindex];
			PORTA = PORTA ^ timings[MaskPort_A][timingindex];
			PORTE = PORTE ^ timings[MaskPort_E][timingindex];
			PORTD = PORTD ^ timings[MaskPort_D][timingindex];
			timingindex++;
		}
		// the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 4 usec.
		__asm 
			movlw 6
			movwf _loopvar
		bucle:
			NOP
			decfsz _loopvar,1
			goto bucle
		__endasm;
	}
}

static void ServosPulseUp()
{
// This function starts up pulses for all activated servos.
	PORTB = activatedservos[MaskPort_B] & 0xFF;
	PORTC = activatedservos[MaskPort_C] & 0xFF;
	PORTA = activatedservos[MaskPort_A] & 0xFF;
	PORTE = activatedservos[MaskPort_E] & 0xFF;
	PORTD = activatedservos[MaskPort_D] & 0xFF;		
}


static void SortServoTimings()
{
// This funtion analyses servovalues table and creates and ordered table(timings)
// from smaller to bigger of all the values, asociating to each 
// position of the table the servos that matches that timing.

	u8 s,t,totalservos,numservos;
	u8 mascaratotal[5]={0x00,0x00,0x00,0x00,0x00};
	
	// inicializamos la tabla:
	for(t=0;t<30;t++){
		timings[timevalue][t]=255;
		timings[MaskPort_B][t]=0x00;
		timings[MaskPort_C][t]=0x00;
		timings[MaskPort_A][t]=0x00;
		timings[MaskPort_E][t]=0x00;
		timings[MaskPort_D][t]=0x00;
	}
	
	totalservos=0;
	t=0;
	while(totalservos<30) {
		numservos=1;
		for(s=0;s<30;s++) { 
			// Case that we are reviewing PORTB servos:
			if (s>=3 && s<=10){
				if (servomasks[s] & mascaratotal[MaskPort_B] & activatedservos[MaskPort_B]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=servomasks[s];
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					timings[MaskPort_E][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_B][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTA servos:
			else if ((s==2) || (s>=14 && s<=18)){
				if (servomasks[s] & mascaratotal[MaskPort_A] & activatedservos[MaskPort_A]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=servomasks[s];
					timings[MaskPort_E][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_A][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTC servos:
			else if (s<2 || (s>=11 && s<=13)){
				if (servomasks[s] & mascaratotal[MaskPort_C] & activatedservos[MaskPort_C]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=servomasks[s];
					timings[MaskPort_A][t]=0x00;
					timings[MaskPort_E][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_C][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTE servos:
			else if (s>=19 && s<=21){
				if (servomasks[s] & mascaratotal[MaskPort_E] & activatedservos[MaskPort_E]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					timings[MaskPort_E][t]=servomasks[s];
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_E][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTD servos:
			else {
				if (servomasks[s] & mascaratotal[MaskPort_D] & activatedservos[MaskPort_D]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					timings[MaskPort_E][t]=0x00;
					timings[MaskPort_D][t]=servomasks[s];
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_D][t] |= servomasks[s];
					numservos++;
				}
			}				
			
		}
		mascaratotal[MaskPort_B] |= timings[MaskPort_B][t];
		mascaratotal[MaskPort_C] |= timings[MaskPort_C][t];
		mascaratotal[MaskPort_A] |= timings[MaskPort_A][t];
		mascaratotal[MaskPort_E] |= timings[MaskPort_E][t];
		mascaratotal[MaskPort_D] |= timings[MaskPort_D][t];
		totalservos += numservos;
		t++;
	
	}
	needreordering=0;  // This indicates that servo timings is ordered.	
}	


	
void ServoAttach(u8 pin)
{
	if(pin>=30) return;

	if(pin>=3 && pin<=10){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] | servomasks[pin];  // list pin as servo driver.
		TRISB = TRISB & (255 - servomasks[pin]); // set as output pin
	} else if ((pin==2) || (pin>=14 && pin<=18)) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] | servomasks[pin];  // list pin as servo driver.
		TRISA = TRISA & (255 - servomasks[pin]); // set as output pin
	} else if (pin<2 || (pin>=11 && pin <=13)){
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] | servomasks[pin];  // list pin as servo driver.
		TRISC = TRISC & (255 - servomasks[pin]); // set as output pin
	} else if (pin>=19 && pin <=21){
		activatedservos[MaskPort_E] = activatedservos[MaskPort_E] | servomasks[pin];  // list pin as servo driver.
		TRISE = TRISE & (255 - servomasks[pin]); // set as output pin
	} else {
		activatedservos[MaskPort_D] = activatedservos[MaskPort_D] | servomasks[pin];  // list pin as servo driver.
		TRISD = TRISD & (255 - servomasks[pin]); // set as output pin
	}
	
}

void ServoDetach(u8 pin)
{
	if(pin>=30) return;

	if(pin>=3 && pin<=10){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] ^ servomasks[pin];
	} else if ((pin==2) || (pin>=14 && pin<=18)) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] ^ servomasks[pin];
	} else if (pin<2 || (pin>=11 && pin <=13)){
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] ^ servomasks[pin];
	} else if (pin>=19 && pin <=21){
		activatedservos[MaskPort_E] = activatedservos[MaskPort_E] ^ servomasks[pin];
	} else {
		activatedservos[MaskPort_D] = activatedservos[MaskPort_D] ^ servomasks[pin];
	}
	
}

void ServoWrite(u8 servo, u8 value)
{
	if(servo>=30)        // test if numservo is valid
		return;
	
	if(value<SERVOMIN)  //  1 = 1000 useg pulse
		value=SERVOMIN;
	if(value>SERVOMAX) // 250 = 2000 useg pulse
		value=SERVOMAX;
	servovalues[servo]=value;
	
	needreordering=1;  // This indicates servo timings must be reordered.
}


unsigned char ServoRead(u8 servo)
{
	if(servo>=30)        // test if numservo is valid
		return 0;
	return servovalues[servo];
}


void ServoMinimumPulse(u8 servo)
{
	if(servo>=30)        // test if numservo is valid
		return;
	
	servovalues[servo]=SERVOMIN;  //  1 = 1000 useg pulse

	needreordering=1;  // This indicates servo timings must be reordered.
}


void ServoMaximumPulse(u8 servo)
{
	if(servo>=30)        // test if numservo is valid
		return;
	
	servovalues[servo]=SERVOMAX;  //  250 = 2000 useg pulse

	needreordering=1;  // This indicates servo timings must be reordered.
}



//interrupt handler that handles servos
void servos_interrupt(void)
{
	if (PIR1bits.TMR1IF) {
		PIR1bits.TMR1IF=0;
		T1CON=0x00;
		if (phase) {
		//case before 1st ms:
			ServosPulseUp();
			// Load at TMR1 54159d(also 0xFFFF - 12000d (- 54usec for adjustments)).
			TMR1H= 0xd3;
			TMR1L= 0x8f;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (CPU clock or Fosc=48Mhz).
			T1CON=1;
			phase = 0;
		} 
		else {
		//case before 2nd ms:
			//The following call takes 1 ms aprox.:
			ServosPulseDown();
			// Now it takes place a 18 ms delay, after that a interrupt will be generated.
			// Loading at TMR1 11535d (que es: 0xFFFF - (4,5 x 12000(duracion 1ms)) = 0x2D0F => a 4,5 ms) 
			// This 4,5 x 4 (with preescaler x 4) we get 18 ms delay.
			TMR1H= 0x2d;
			TMR1L= 0x0f;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (recordemos que Fosc=48Mhz).
			if (needreordering)	
				SortServoTimings();  // This takes more than 1 ms, but it's call only if needed.
			T1CON= ( 1 | 2 << 4 ) ; // activate timer1 and prescaler = 1:4
			phase = 1;  //This indicates that after next interrupt it will start the servos cycle.
		} 
	}
	return;
}
//----------------------------------------------------------------------------------------------------------------------------------
#else
u8 timingindex;
u8 timedivision=0;
u8 loopvar;
u8 timings[4][18];  
u8 activatedservos[3]={0x00,0x00,0x00};
// For referencing masks in the previous array.
#define MaskPort_B  0
#define MaskPort_C  1
#define MaskPort_A  2
#define timevalue   3

u8 servovalues[18]; // Entry table for values sets for every pin-servo.

//Masks table:
//u8 servomasks[8]={ 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };
// The following masks are in this order : PORTB (8 bits), PORTC (5bits) & PORTA (5bits)
const u8 servomasks[18]={0X01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x40,0x80,0x01,0x02,0x04,0x01,0x02,0x04,0x08,0x20};


 
void servos_init()
{
	unsigned char a;

	for(a=0;a<18;a++) servovalues[a]=255;

	TMR1H=0xFF;
	TMR1L=0x00;
	// timer 1 prescaler 1 source is internal oscillator
	T1CON=0x01;

    PIR1bits.TMR1IF=0;              // Clear interrupt flag
    PIE1bits.TMR1IE=1;              // Enable interrupt for timer1 in register PIE1
    IPR1bits.TMR1IP=1;              // High priority
    //RCONbits.IPEN = 1;              // Enable interrupt priorities
    INTCONbits.GIEH = 1;            // Enable global HP interrupts
    INTCONbits.GIEL = 1;            // Enable global LP interrupts
}


static void ServosPulseDown()
{
	timingindex = 0;
	
	for(timedivision=0;timedivision < 251;timedivision++){
		if (timings[timevalue][timingindex] == timedivision){
			PORTB = PORTB ^ timings[MaskPort_B][timingindex];
			PORTC = PORTC ^ timings[MaskPort_C][timingindex];
			PORTA = PORTA ^ timings[MaskPort_A][timingindex];
			timingindex++;
		}
		// the following routine adds the requiered delay for every tick of timedivision, so every timedivision last 4 usec.
		__asm 
			movlw 6
			movwf _loopvar
		bucle:
			NOP
			decfsz _loopvar,1
			goto bucle
		__endasm;
	}
}

static void ServosPulseUp()
{
// This function starts up pulses for all activated servos.
	PORTB = activatedservos[MaskPort_B] & 0xFF;
	PORTC = activatedservos[MaskPort_C] & 0xFF;
	PORTA = activatedservos[MaskPort_A] & 0xFF;	
}


static void SortServoTimings()
{
// This funtion analyses servovalues table and creates and ordered table(timings)
// from smaller to bigger of all the values, asociating to each 
// position of the table the servos that matches that timing.

	u8 s,t,totalservos,numservos;
	u8 mascaratotal[3]={0x00,0x00,0x00};
	
	// inicializamos la tabla:
	for(t=0;t<18;t++){
		timings[timevalue][t]=255;
		timings[MaskPort_B][t]=0x00;
		timings[MaskPort_C][t]=0x00;
		timings[MaskPort_A][t]=0x00;
	}
	
	totalservos=0;
	t=0;
	while(totalservos<18) {
		numservos=1;
		for(s=0;s<18;s++) { 
			// Case that we are reviewing PORTB servos:
			if (s<8){
				if (servomasks[s] & mascaratotal[MaskPort_B] & activatedservos[MaskPort_B]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=servomasks[s];
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_B][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTA servos:
			else if (s>12){
				if (servomasks[s] & mascaratotal[MaskPort_A] & activatedservos[MaskPort_A]){
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=0x00;
					timings[MaskPort_A][t]=servomasks[s];
					numservos=1;
				}
				else if (servovalues[s] == timings[timevalue][t]){
					timings[MaskPort_A][t] |= servomasks[s];
					numservos++;
				}
			}
			// Case that we are reviewing PORTC servos:
			else {
				if (servomasks[s] & mascaratotal[MaskPort_C] & activatedservos[MaskPort_C]){ 
				}
				else if (servovalues[s] < timings[timevalue][t]){
					timings[timevalue][t]=servovalues[s];
					timings[MaskPort_B][t]=0x00;
					timings[MaskPort_C][t]=servomasks[s];
					timings[MaskPort_A][t]=0x00;
					numservos=1;
				}
				else if (servovalues[s] == timings [timevalue][t]){
					timings[MaskPort_C][t] |= servomasks[s];
					numservos++;
				}
			}				
			
		}
		mascaratotal[MaskPort_B] |= timings[MaskPort_B][t];
		mascaratotal[MaskPort_C] |= timings[MaskPort_C][t];
		mascaratotal[MaskPort_A] |= timings[MaskPort_A][t];
		totalservos += numservos;
		t++;
	
	}
	needreordering=0;  // This indicates that servo timings is ordered.	
}	


	
void ServoAttach(u8 pin)
{
	if(pin>=18) return;

	if(pin<8){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] | servomasks[pin];  // list pin as servo driver.
		TRISB = TRISB & (255 - servomasks[pin]); // set as output pin
	} else if (pin>12) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] | servomasks[pin];  // list pin as servo driver.
		TRISA = TRISA & (255 - servomasks[pin]); // set as output pin
	} else {
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] | servomasks[pin];  // list pin as servo driver.
		TRISC = TRISC & (255 - servomasks[pin]); // set as output pin
	}
	
}

void ServoDetach(u8 pin)
{
	if(pin>=18) return;

	if(pin<8){
		activatedservos[MaskPort_B] = activatedservos[MaskPort_B] ^ servomasks[pin];
	} else if (pin>12) {
		activatedservos[MaskPort_A] = activatedservos[MaskPort_A] ^ servomasks[pin];
	} else {
		activatedservos[MaskPort_C] = activatedservos[MaskPort_C] ^ servomasks[pin];
	}
	
}

void ServoWrite(u8 servo, u8 value)
{
	if(servo>=18)        // test if numservo is valid
		return;
	
	if(value<SERVOMIN)  //  1 = 1000 useg pulse
		value=SERVOMIN;
	if(value>SERVOMAX) // 250 = 2000 useg pulse
		value=SERVOMAX;
	servovalues[servo]=value;
	
	needreordering=1;  // This indicates servo timings must be reordered.
}


unsigned char ServoRead(u8 servo)
{
	if(servo>=18)        // test if numservo is valid
		return 0;
	return servovalues[servo];
}


void ServoMinimumPulse(u8 servo)
{
	if(servo>=18)        // test if numservo is valid
		return;
	
	servovalues[servo]=SERVOMIN;  //  1 = 1000 useg pulse

	needreordering=1;  // This indicates servo timings must be reordered.
}


void ServoMaximumPulse(u8 servo)
{
	if(servo>=18)        // test if numservo is valid
		return;
	
	servovalues[servo]=SERVOMAX;  //  250 = 2000 useg pulse

	needreordering=1;  // This indicates servo timings must be reordered.
}



//interrupt handler that handles servos
void servos_interrupt(void)
{
	if (PIR1bits.TMR1IF) {
		PIR1bits.TMR1IF=0;
		T1CON=0x00;
		if (phase) {
		//case before 1st ms:
			ServosPulseUp();
			// Load at TMR1 54159d(also 0xFFFF - 12000d (- 54usec for adjustments)).
			TMR1H= 0xd3;
			TMR1L= 0x8f;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (CPU clock or Fosc=48Mhz).
			T1CON=1;
			phase = 0;
		} 
		else {
		//case before 2nd ms:
			//The following call takes 1 ms aprox.:
			ServosPulseDown();
			// Now it takes place a 18 ms delay, after that a interrupt will be generated.
			// Loading at TMR1 11535d (que es: 0xFFFF - (4,5 x 12000(duracion 1ms)) = 0x2D0F => a 4,5 ms) 
			// This 4,5 x 4 (with preescaler x 4) we get 18 ms delay.
			TMR1H= 0x2d;
			TMR1L= 0x0f;
			// timer 1 prescaler 1 source is internal oscillator Fosc/4 (recordemos que Fosc=48Mhz).
			if (needreordering)	
				SortServoTimings();  // This takes more than 1 ms, but it's call only if needed.
			T1CON= ( 1 | 2 << 4 ) ; // activate timer1 and prescaler = 1:4
			phase = 1;  //This indicates that after next interrupt it will start the servos cycle.
		} 
	}
	return;
}
#endif
